<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>分享技术 品味生活</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name">分享技术 品味生活</h1>
  <h2 class="project-tagline">talk is cheap, show me the code</h2>
  <a href="https://github.com/qinglongyanyue/blog" class="btn">View on GitHub</a>
</section>

    <section class="main-content">
      
      <h2 id="1-背景">1. 背景</h2>
<p>跨地域的数据中心，跨国企业，云存储领域都有全球各地的数据中心，需要这些跨地域的数据能够一致性的，高效，可靠的支持跨区域的访问。
现在主要的分布式文件系统都是单数据中心的设计，无法搞定跨地域的情况，本论文就是解决这个问题的。</p>

<h3 id="11-gpfs介绍">1.1 GPFS介绍</h3>
<p>IBM的产品，2002年在FAST发表过论文，核心特色是其分布式锁的设计。在高性能计算领域这样的场景比较适合，也支持跑oracle RAC之类的。</p>

<h3 id="12-pnfs介绍">1.2 pNFS介绍</h3>
<p>NFSv4.1的一个核心特性，一个标准的分布式文件系统，当然只有client是标准的，MDS和OSD之类的还得自己实现。</p>

<p>下图是一个基于GPFS的pNFS实现。</p>

<p><img src="/assets/pancache-1.png" alt="" /></p>

<h2 id="2-panache是啥">2. Panache是啥？</h2>
<ul>
  <li>一个多节点、读写cache，端到端的并行，消除性能瓶颈
    <ul>
      <li>并行读入：当cache miss的时候，并行从多个节点，多个file读入数据</li>
      <li>外部对于cache的访问也是并行的</li>
      <li>写操作也是并行的，包括多个节点的写操作</li>
      <li>数据刷回也是并行的</li>
      <li>元数据刷回也是并行的</li>
    </ul>
  </li>
</ul>

<h2 id="3-panache架构">3. Panache架构</h2>

<p>设计原则：</p>

<ul>
  <li>数据和元数据的读必须尽量由本地来搞定，而不是跨地域的读</li>
  <li>读miss时，瓶颈只能是网络</li>
  <li>写必须是本地化的体验</li>
  <li>当网络断开时，cache也能继续提供服务</li>
</ul>

<p>Panache主要价值：</p>
<ul>
  <li>Panache是GPFS的一个组件，能否缓存远程集群的数据和元数据</li>
  <li>让分布各处的应用就像访问本地一样的访问数据</li>
  <li>读不明中时，并发的去远端拉取，写先写本地，然后异步刷到远端。</li>
  <li>即可能当cache，也可以当存储，网络断掉时，不影响应用。</li>
</ul>

<p><img src="/assets/pancache-2.png" alt="" /></p>

<p>架构图包括四个部件：app node，cache集群，代理node，远端NFS。</p>

<p>Cloudfs可以依照这个思路，DIY一个demo试试。</p>

<h3 id="31-panache一致性方案">3.1 Panache一致性方案</h3>
<ul>
  <li>本地一致性：本地集群读到的数据是本地最近写的数据</li>
  <li>validity lag：本地读到远程更新的时间差，可配置；配置为0，即每次读都到远程读。</li>
  <li>sync lag：远程读到cache新写的内容的时间差，可配置；配置为0，即每个IO都实时同步到远程。</li>
  <li>最终一致性：在网络或者节点失效恢复时，不出现新错误的情况下，数据最终达到一致。</li>
</ul>

<p>NFS（应该是NFS3）对于缓存的数据（包括元数据），每隔30秒会到server侧check下是否有变化。NFSv4则更先进，能把cache管理卸载给client，client自己来协调，保证cache一致性。</p>

<h2 id="4-一些同步操作">4. 一些同步操作</h2>
<p>同步操作是指需要远端执行完才能继续的操作，比如读cache miss，数据已经失效等。
这种操作损失很大，需要尽量去减少这种读不命中的情况。</p>

<ul>
  <li>元数据读：当第一次访问一个文件对象时，在cache创建一个空的对象；并用NFS file－handle与远程对象关联（存放在inode的扩展属性中）。基本动作如下：
    <ul>
      <li>应用节点发送请求到代理节点（hash对象inode或者父目录inide）</li>
      <li>代理节点把请求发送到远端NFS server</li>
      <li>一旦在远程节点获取成功，返回代理节点，代理节点在cache中创建一个空对象，并用返回值填充</li>
      <li>代理节点对应用节点返回成功。</li>
      <li>下次再读同样的内容就会命中。</li>
    </ul>
  </li>
  <li>数据读：当cache中没有命中数据时，将请求发送到代理节点，代理节点根据预取策略去远端读取数据，读取成功后写入cache。</li>
  <li>名字空间cache：名字空间需要确保cache侧和远端的一致性。这样ls类的操作才能保证本地和远端一致。流程如下：
    <ul>
      <li>对于ls操作，首先到远端拉取最新的（name，inode号）列表。</li>
      <li>根据远端的信息在本地创建inode，并返回本地的（name，inode号）到应用，即inode号是独立管理的。(这样当网络断掉时，应用也能继续访问)</li>
    </ul>
  </li>
  <li>数据和元数据重新生效
    <ul>
      <li>每个inode都存放了本地创建和修改时间，以及远程的创建和修改时间</li>
      <li>每隔一个时间（比如30秒，NFS3），检查远程对象的创建和修改时间，如果不一样就用远程覆盖本地的。</li>
      <li>NFS4略有不同。（得分析下NFS3和NFS4的cache原理）</li>
    </ul>
  </li>
</ul>

<h2 id="5-一些异步操作">5. 一些异步操作</h2>
<p>对于所有的元数据和数据的更新，我们需要屏蔽掉远程的访问，所以写操作都是异步刷新的。</p>

<h3 id="51-相关联的元数据操作">5.1 相关联的元数据操作</h3>

<p>每个代理节点都有一个内存的queue，queue每个条目包括：&lt;inode_num,gen_num,fsid&gt;。如果只有一个代理，可以保证刷新按照顺序来，如果多个代理，如何保证刷新的顺序和收到IO的顺序一致呢？</p>

<p>定义1:首先我们定义一下 “时间顺序”：
对于一个对象X的2个修改Ci（X）和Cj（X），tj &gt; ti，如果在远端也需要以同样的时间顺序执行，则称这2个操作是时间顺序的。</p>

<p>比如创建文件和写文件这2个操作就是时间顺序的。</p>

<p>定义2:再定义下“关联对象”：对于2个对象Ox和Oy，如果存在2个操作Ci（Ox）和Cj（Oy）是时间顺序的，那么这2个对象就是关联对象。</p>

<p>比如创建一个文件对象Filex和它的父目录对象Diry就是典型的例子。</p>

<p>定义3:如果一组操作即没有时间顺序，也不是关联对象，那么这些操作就是可并行的。</p>

<h3 id="52-数据写操作">5.2 数据写操作</h3>
<p>首先写本地cache，然后写远程。</p>

<p>需要做几个优化：</p>
<ul>
  <li>把IO合并起来，以大块(NFS的最大块粒度)的方式发送</li>
  <li>消除一些多次写</li>
  <li>如果远程down掉，本地继续服务，退化成一种最终一致性的方案。</li>
</ul>



      <footer class="site-footer">
  <span class="site-footer-owner"><a href="http://localhost:4000">分享技术 品味生活</a> is maintained by <a href="l.ming@huawei.com">Author mingliang</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
</footer>


    </section>

  </body>
</html>
