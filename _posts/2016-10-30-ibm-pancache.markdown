---
layout: default
title:  "IBM Pancache论文分析"
date:   2016-10-30
categories: filesystem
---


## 1. 背景
跨地域的数据中心，跨国企业，云存储领域都有全球各地的数据中心，需要这些跨地域的数据能够一致性的，高效，可靠的支持跨区域的访问。
现在主要的分布式文件系统都是单数据中心的设计，无法搞定跨地域的情况，本论文就是解决这个问题的。

### 1.1 GPFS介绍
IBM的产品，2002年在FAST发表过论文，核心特色是其分布式锁的设计。在高性能计算领域这样的场景比较适合，也支持跑oracle RAC之类的。

### 1.2 pNFS介绍
NFSv4.1的一个核心特性，一个标准的分布式文件系统，当然只有client是标准的，MDS和OSD之类的还得自己实现。

下图是一个基于GPFS的pNFS实现。

![]({{ site.baseurl }}/assets/pancache-1.png)

## 2. Panache是啥？
- 一个多节点、读写cache，端到端的并行，消除性能瓶颈
  - 并行读入：当cache miss的时候，并行从多个节点，多个file读入数据
  - 外部对于cache的访问也是并行的
  - 写操作也是并行的，包括多个节点的写操作
  - 数据刷回也是并行的
  - 元数据刷回也是并行的

## 3. Panache架构

设计原则：

- 数据和元数据的读必须尽量由本地来搞定，而不是跨地域的读
- 读miss时，瓶颈只能是网络
- 写必须是本地化的体验
- 当网络断开时，cache也能继续提供服务

Panache主要价值：
- Panache是GPFS的一个组件，能否缓存远程集群的数据和元数据
- 让分布各处的应用就像访问本地一样的访问数据
- 读不明中时，并发的去远端拉取，写先写本地，然后异步刷到远端。
- 即可能当cache，也可以当存储，网络断掉时，不影响应用。

![]({{ site.baseurl }}/assets/pancache-2.png)

架构图包括四个部件：app node，cache集群，代理node，远端NFS。

Cloudfs可以依照这个思路，DIY一个demo试试。

### 3.1 Panache一致性方案
- 本地一致性：本地集群读到的数据是本地最近写的数据
- validity lag：本地读到远程更新的时间差，可配置；配置为0，即每次读都到远程读。
- sync lag：远程读到cache新写的内容的时间差，可配置；配置为0，即每个IO都实时同步到远程。
- 最终一致性：在网络或者节点失效恢复时，不出现新错误的情况下，数据最终达到一致。

NFS（应该是NFS3）对于缓存的数据（包括元数据），每隔30秒会到server侧check下是否有变化。NFSv4则更先进，能把cache管理卸载给client，client自己来协调，保证cache一致性。

## 4. 一些同步操作
同步操作是指需要远端执行完才能继续的操作，比如读cache miss，数据已经失效等。
这种操作损失很大，需要尽量去减少这种读不命中的情况。

- 元数据读：当第一次访问一个文件对象时，在cache创建一个空的对象；并用NFS file－handle与远程对象关联（存放在inode的扩展属性中）。基本动作如下：
  - 应用节点发送请求到代理节点（hash对象inode或者父目录inide）
  - 代理节点把请求发送到远端NFS server
  - 一旦在远程节点获取成功，返回代理节点，代理节点在cache中创建一个空对象，并用返回值填充
  - 代理节点对应用节点返回成功。
  - 下次再读同样的内容就会命中。
- 数据读：当cache中没有命中数据时，将请求发送到代理节点，代理节点根据预取策略去远端读取数据，读取成功后写入cache。
- 名字空间cache：名字空间需要确保cache侧和远端的一致性。这样ls类的操作才能保证本地和远端一致。流程如下：
  - 对于ls操作，首先到远端拉取最新的（name，inode号）列表。
  - 根据远端的信息在本地创建inode，并返回本地的（name，inode号）到应用，即inode号是独立管理的。(这样当网络断掉时，应用也能继续访问)
- 数据和元数据重新生效
  - 每个inode都存放了本地创建和修改时间，以及远程的创建和修改时间
  - 每隔一个时间（比如30秒，NFS3），检查远程对象的创建和修改时间，如果不一样就用远程覆盖本地的。
  - NFS4略有不同。（得分析下NFS3和NFS4的cache原理）

## 5. 一些异步操作
对于所有的元数据和数据的更新，我们需要屏蔽掉远程的访问，所以写操作都是异步刷新的。

### 5.1 相关联的元数据操作

每个代理节点都有一个内存的queue，queue每个条目包括：<inode_num,gen_num,fsid>。如果只有一个代理，可以保证刷新按照顺序来，如果多个代理，如何保证刷新的顺序和收到IO的顺序一致呢？

定义1:首先我们定义一下 “时间顺序”：
对于一个对象X的2个修改Ci（X）和Cj（X），tj > ti，如果在远端也需要以同样的时间顺序执行，则称这2个操作是时间顺序的。

比如创建文件和写文件这2个操作就是时间顺序的。

定义2:再定义下“关联对象”：对于2个对象Ox和Oy，如果存在2个操作Ci（Ox）和Cj（Oy）是时间顺序的，那么这2个对象就是关联对象。

比如创建一个文件对象Filex和它的父目录对象Diry就是典型的例子。

定义3:如果一组操作即没有时间顺序，也不是关联对象，那么这些操作就是可并行的。

### 5.2 数据写操作
首先写本地cache，然后写远程。

需要做几个优化：
- 把IO合并起来，以大块(NFS的最大块粒度)的方式发送
- 消除一些多次写
- 如果远程down掉，本地继续服务，退化成一种最终一致性的方案。

